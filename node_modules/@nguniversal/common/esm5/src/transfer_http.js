var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
import { HTTP_INTERCEPTORS, HttpHeaders, HttpResponse } from '@angular/common/http';
import { ApplicationRef, Injectable, NgModule } from '@angular/core';
import { BrowserTransferStateModule, TransferState, makeStateKey } from '@angular/platform-browser';
import { of as observableOf } from 'rxjs';
import { tap, take, filter } from 'rxjs/operators';
function getHeadersMap(headers) {
    var headersMap = {};
    try {
        for (var _a = __values(headers.keys()), _b = _a.next(); !_b.done; _b = _a.next()) {
            var key = _b.value;
            headersMap[key] = (headers.getAll(key));
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return headersMap;
    var e_1, _c;
}
var TransferHttpCacheInterceptor = /** @class */ (function () {
    function TransferHttpCacheInterceptor(appRef, transferState) {
        var _this = this;
        this.transferState = transferState;
        this.isCacheActive = true;
        // Stop using the cache if the application has stabilized, indicating initial rendering is
        // complete.
        appRef.isStable
            .pipe(filter(function (isStable) { return isStable; }), take(1)).toPromise()
            .then(function () { _this.isCacheActive = false; });
    }
    TransferHttpCacheInterceptor.prototype.invalidateCacheEntry = function (url) {
        this.transferState.remove(makeStateKey('G.' + url));
        this.transferState.remove(makeStateKey('H.' + url));
    };
    TransferHttpCacheInterceptor.prototype.intercept = function (req, next) {
        var _this = this;
        // Stop using the cache if there is a mutating call.
        if (req.method !== 'GET' && req.method !== 'HEAD') {
            this.isCacheActive = false;
            this.invalidateCacheEntry(req.url);
        }
        if (!this.isCacheActive) {
            // Cache is no longer active. Pass the request through.
            return next.handle(req);
        }
        var key = (req.method === 'GET' ? 'G.' : 'H.') + req.url;
        var storeKey = makeStateKey(key);
        if (this.transferState.hasKey(storeKey)) {
            // Request found in cache. Respond using it.
            var response = this.transferState.get(storeKey, {});
            return observableOf(new HttpResponse({
                body: response.body,
                headers: new HttpHeaders(response.headers),
                status: response.status,
                statusText: response.statusText,
                url: response.url,
            }));
        }
        else {
            // Request not found in cache. Make the request and cache it.
            var httpEvent = next.handle(req);
            return httpEvent
                .pipe(tap(function (event) {
                if (event instanceof HttpResponse) {
                    _this.transferState.set(storeKey, {
                        body: event.body,
                        headers: getHeadersMap(event.headers),
                        status: event.status,
                        statusText: event.statusText,
                        url: (event.url),
                    });
                }
            }));
        }
    };
    TransferHttpCacheInterceptor.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    TransferHttpCacheInterceptor.ctorParameters = function () { return [
        { type: ApplicationRef, },
        { type: TransferState, },
    ]; };
    return TransferHttpCacheInterceptor;
}());
export { TransferHttpCacheInterceptor };
/**
 * An NgModule used in conjunction with `ServerTransferHttpCacheModule` to transfer cached HTTP
 * calls from the server to the client application.
 */
var TransferHttpCacheModule = /** @class */ (function () {
    function TransferHttpCacheModule() {
    }
    TransferHttpCacheModule.decorators = [
        { type: NgModule, args: [{
                    imports: [BrowserTransferStateModule],
                    providers: [
                        TransferHttpCacheInterceptor,
                        { provide: HTTP_INTERCEPTORS, useExisting: TransferHttpCacheInterceptor, multi: true },
                    ],
                },] }
    ];
    return TransferHttpCacheModule;
}());
export { TransferHttpCacheModule };

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNmZXJfaHR0cC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL21vZHVsZXMvY29tbW9uL3NyYy90cmFuc2Zlcl9odHRwLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFPQSxPQUFPLEVBQ0wsaUJBQWlCLEVBR2pCLFdBQVcsRUFHWCxZQUFZLEVBQ2IsTUFBTSxzQkFBc0IsQ0FBQztBQUM5QixPQUFPLEVBQUMsY0FBYyxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDbkUsT0FBTyxFQUFDLDBCQUEwQixFQUFFLGFBQWEsRUFBRSxZQUFZLEVBQUMsTUFBTSwyQkFBMkIsQ0FBQztBQUNsRyxPQUFPLEVBQWEsRUFBRSxJQUFJLFlBQVksRUFBQyxNQUFNLE1BQU0sQ0FBQztBQUNwRCxPQUFPLEVBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQztBQVVqRCx1QkFBdUIsT0FBb0I7SUFDekMsSUFBTSxVQUFVLEdBQStCLEVBQUUsQ0FBQzs7UUFDbEQsR0FBRyxDQUFDLENBQWMsSUFBQSxLQUFBLFNBQUEsT0FBTyxDQUFDLElBQUksRUFBRSxDQUFBLGdCQUFBO1lBQTNCLElBQU0sR0FBRyxXQUFBO1lBQ1osVUFBVSxDQUFDLEdBQUcsQ0FBQyxJQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFFLENBQUEsQ0FBQztTQUN4Qzs7Ozs7Ozs7O0lBQ0QsTUFBTSxDQUFDLFVBQVUsQ0FBQzs7Q0FDbkI7O0lBWUMsc0NBQVksTUFBc0IsRUFBVSxhQUE0QjtRQUF4RSxpQkFTQztRQVQyQyxrQkFBYSxHQUFiLGFBQWEsQ0FBZTs2QkFQaEQsSUFBSTs7O1FBVTFCLE1BQU0sQ0FBQyxRQUFRO2FBQ1osSUFBSSxDQUNILE1BQU0sQ0FBQyxVQUFDLFFBQWlCLElBQUssT0FBQSxRQUFRLEVBQVIsQ0FBUSxDQUFDLEVBQ3ZD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MEJBQTBCLENBQUM7b0JBQ3JDLFNBQVMsRUFBRTt3QkFDVCw0QkFBNEI7d0JBQzVCLEVBQUMsT0FBTyxFQUFFLGlCQUFpQixFQUFFLFdBQVcsRUFBRSw0QkFBNEIsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFDO3FCQUNyRjtpQkFDRjs7a0NBbEhEOztTQW1IYSx1QkFBdUIiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmltcG9ydCB7XG4gIEhUVFBfSU5URVJDRVBUT1JTLFxuICBIdHRwRXZlbnQsXG4gIEh0dHBIYW5kbGVyLFxuICBIdHRwSGVhZGVycyxcbiAgSHR0cEludGVyY2VwdG9yLFxuICBIdHRwUmVxdWVzdCxcbiAgSHR0cFJlc3BvbnNlXG59IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcbmltcG9ydCB7QXBwbGljYXRpb25SZWYsIEluamVjdGFibGUsIE5nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7QnJvd3NlclRyYW5zZmVyU3RhdGVNb2R1bGUsIFRyYW5zZmVyU3RhdGUsIG1ha2VTdGF0ZUtleX0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlcic7XG5pbXBvcnQge09ic2VydmFibGUsIG9mIGFzIG9ic2VydmFibGVPZn0gZnJvbSAncnhqcyc7XG5pbXBvcnQge3RhcCwgdGFrZSwgZmlsdGVyfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNmZXJIdHRwUmVzcG9uc2Uge1xuICBib2R5PzogYW55IHwgbnVsbDtcbiAgaGVhZGVycz86IHtbazogc3RyaW5nXTogc3RyaW5nW119O1xuICBzdGF0dXM/OiBudW1iZXI7XG4gIHN0YXR1c1RleHQ/OiBzdHJpbmc7XG4gIHVybD86IHN0cmluZztcbn1cblxuZnVuY3Rpb24gZ2V0SGVhZGVyc01hcChoZWFkZXJzOiBIdHRwSGVhZGVycykge1xuICBjb25zdCBoZWFkZXJzTWFwOiB7W25hbWU6IHN0cmluZ106IHN0cmluZ1tdfSA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBvZiBoZWFkZXJzLmtleXMoKSkge1xuICAgIGhlYWRlcnNNYXBba2V5XSA9IGhlYWRlcnMuZ2V0QWxsKGtleSkhO1xuICB9XG4gIHJldHVybiBoZWFkZXJzTWFwO1xufVxuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgVHJhbnNmZXJIdHRwQ2FjaGVJbnRlcmNlcHRvciBpbXBsZW1lbnRzIEh0dHBJbnRlcmNlcHRvciB7XG5cbiAgcHJpdmF0ZSBpc0NhY2hlQWN0aXZlID0gdHJ1ZTtcblxuICBwcml2YXRlIGludmFsaWRhdGVDYWNoZUVudHJ5KHVybDogc3RyaW5nKSB7XG4gICAgdGhpcy50cmFuc2ZlclN0YXRlLnJlbW92ZShtYWtlU3RhdGVLZXk8VHJhbnNmZXJIdHRwUmVzcG9uc2U+KCdHLicgKyB1cmwpKTtcbiAgICB0aGlzLnRyYW5zZmVyU3RhdGUucmVtb3ZlKG1ha2VTdGF0ZUtleTxUcmFuc2Zlckh0dHBSZXNwb25zZT4oJ0guJyArIHVybCkpO1xuICB9XG5cbiAgY29uc3RydWN0b3IoYXBwUmVmOiBBcHBsaWNhdGlvblJlZiwgcHJpdmF0ZSB0cmFuc2ZlclN0YXRlOiBUcmFuc2ZlclN0YXRlKSB7XG4gICAgLy8gU3RvcCB1c2luZyB0aGUgY2FjaGUgaWYgdGhlIGFwcGxpY2F0aW9uIGhhcyBzdGFiaWxpemVkLCBpbmRpY2F0aW5nIGluaXRpYWwgcmVuZGVyaW5nIGlzXG4gICAgLy8gY29tcGxldGUuXG4gICAgYXBwUmVmLmlzU3RhYmxlXG4gICAgICAucGlwZShcbiAgICAgICAgZmlsdGVyKChpc1N0YWJsZTogYm9vbGVhbikgPT4gaXNTdGFibGUpLFxuICAgICAgICB0YWtlKDEpXG4gICAgICApLnRvUHJvbWlzZSgpXG4gICAgICAudGhlbigoKSA9PiB7IHRoaXMuaXNDYWNoZUFjdGl2ZSA9IGZhbHNlOyB9KTtcbiAgfVxuXG4gIGludGVyY2VwdChyZXE6IEh0dHBSZXF1ZXN0PGFueT4sIG5leHQ6IEh0dHBIYW5kbGVyKTogT2JzZXJ2YWJsZTxIdHRwRXZlbnQ8YW55Pj4ge1xuICAgIC8vIFN0b3AgdXNpbmcgdGhlIGNhY2hlIGlmIHRoZXJlIGlzIGEgbXV0YXRpbmcgY2FsbC5cbiAgICBpZiAocmVxLm1ldGhvZCAhPT0gJ0dFVCcgJiYgcmVxLm1ldGhvZCAhPT0gJ0hFQUQnKSB7XG4gICAgICB0aGlzLmlzQ2FjaGVBY3RpdmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZUNhY2hlRW50cnkocmVxLnVybCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmlzQ2FjaGVBY3RpdmUpIHtcbiAgICAgIC8vIENhY2hlIGlzIG5vIGxvbmdlciBhY3RpdmUuIFBhc3MgdGhlIHJlcXVlc3QgdGhyb3VnaC5cbiAgICAgIHJldHVybiBuZXh0LmhhbmRsZShyZXEpO1xuICAgIH1cblxuICAgIGNvbnN0IGtleSA9IChyZXEubWV0aG9kID09PSAnR0VUJyA/ICdHLicgOiAnSC4nKSArIHJlcS51cmw7XG4gICAgY29uc3Qgc3RvcmVLZXkgPSBtYWtlU3RhdGVLZXk8VHJhbnNmZXJIdHRwUmVzcG9uc2U+KGtleSk7XG5cbiAgICBpZiAodGhpcy50cmFuc2ZlclN0YXRlLmhhc0tleShzdG9yZUtleSkpIHtcbiAgICAgIC8vIFJlcXVlc3QgZm91bmQgaW4gY2FjaGUuIFJlc3BvbmQgdXNpbmcgaXQuXG4gICAgICBjb25zdCByZXNwb25zZSA9IHRoaXMudHJhbnNmZXJTdGF0ZS5nZXQoc3RvcmVLZXksIHt9IGFzIFRyYW5zZmVySHR0cFJlc3BvbnNlKTtcbiAgICAgIHJldHVybiBvYnNlcnZhYmxlT2YobmV3IEh0dHBSZXNwb25zZTxhbnk+KHtcbiAgICAgICAgYm9keTogcmVzcG9uc2UuYm9keSxcbiAgICAgICAgaGVhZGVyczogbmV3IEh0dHBIZWFkZXJzKHJlc3BvbnNlLmhlYWRlcnMpLFxuICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgdXJsOiByZXNwb25zZS51cmwsXG4gICAgICB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlcXVlc3Qgbm90IGZvdW5kIGluIGNhY2hlLiBNYWtlIHRoZSByZXF1ZXN0IGFuZCBjYWNoZSBpdC5cbiAgICAgIGNvbnN0IGh0dHBFdmVudCA9IG5leHQuaGFuZGxlKHJlcSk7XG4gICAgICByZXR1cm4gaHR0cEV2ZW50XG4gICAgICAgIC5waXBlKFxuICAgICAgICAgIHRhcCgoZXZlbnQ6IEh0dHBFdmVudDxhbnk+KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBIdHRwUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgdGhpcy50cmFuc2ZlclN0YXRlLnNldChzdG9yZUtleSwge1xuICAgICAgICAgICAgICAgIGJvZHk6IGV2ZW50LmJvZHksXG4gICAgICAgICAgICAgICAgaGVhZGVyczogZ2V0SGVhZGVyc01hcChldmVudC5oZWFkZXJzKSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IGV2ZW50LnN0YXR1cyxcbiAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiBldmVudC5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgIHVybDogZXZlbnQudXJsISxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBOZ01vZHVsZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYFNlcnZlclRyYW5zZmVySHR0cENhY2hlTW9kdWxlYCB0byB0cmFuc2ZlciBjYWNoZWQgSFRUUFxuICogY2FsbHMgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBjbGllbnQgYXBwbGljYXRpb24uXG4gKi9cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtCcm93c2VyVHJhbnNmZXJTdGF0ZU1vZHVsZV0sXG4gIHByb3ZpZGVyczogW1xuICAgIFRyYW5zZmVySHR0cENhY2hlSW50ZXJjZXB0b3IsXG4gICAge3Byb3ZpZGU6IEhUVFBfSU5URVJDRVBUT1JTLCB1c2VFeGlzdGluZzogVHJhbnNmZXJIdHRwQ2FjaGVJbnRlcmNlcHRvciwgbXVsdGk6IHRydWV9LFxuICBdLFxufSlcbmV4cG9ydCBjbGFzcyBUcmFuc2Zlckh0dHBDYWNoZU1vZHVsZSB7fVxuIl19