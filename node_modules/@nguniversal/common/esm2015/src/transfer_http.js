/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { HTTP_INTERCEPTORS, HttpHeaders, HttpResponse } from '@angular/common/http';
import { ApplicationRef, Injectable, NgModule } from '@angular/core';
import { BrowserTransferStateModule, TransferState, makeStateKey } from '@angular/platform-browser';
import { of as observableOf } from 'rxjs';
import { tap, take, filter } from 'rxjs/operators';
/**
 * @record
 */
export function TransferHttpResponse() { }
function TransferHttpResponse_tsickle_Closure_declarations() {
    /** @type {?|undefined} */
    TransferHttpResponse.prototype.body;
    /** @type {?|undefined} */
    TransferHttpResponse.prototype.headers;
    /** @type {?|undefined} */
    TransferHttpResponse.prototype.status;
    /** @type {?|undefined} */
    TransferHttpResponse.prototype.statusText;
    /** @type {?|undefined} */
    TransferHttpResponse.prototype.url;
}
/**
 * @param {?} headers
 * @return {?}
 */
function getHeadersMap(headers) {
    const /** @type {?} */ headersMap = {};
    for (const /** @type {?} */ key of headers.keys()) {
        headersMap[key] = /** @type {?} */ ((headers.getAll(key)));
    }
    return headersMap;
}
export class TransferHttpCacheInterceptor {
    /**
     * @param {?} appRef
     * @param {?} transferState
     */
    constructor(appRef, transferState) {
        this.transferState = transferState;
        this.isCacheActive = true;
        // Stop using the cache if the application has stabilized, indicating initial rendering is
        // complete.
        appRef.isStable
            .pipe(filter((isStable) => isStable), take(1)).toPromise()
            .then(() => { this.isCacheActive = false; });
    }
    /**
     * @param {?} url
     * @return {?}
     */
    invalidateCacheEntry(url) {
        this.transferState.remove(makeStateKey('G.' + url));
        this.transferState.remove(makeStateKey('H.' + url));
    }
    /**
     * @param {?} req
     * @param {?} next
     * @return {?}
     */
    intercept(req, next) {
        // Stop using the cache if there is a mutating call.
        if (req.method !== 'GET' && req.method !== 'HEAD') {
            this.isCacheActive = false;
            this.invalidateCacheEntry(req.url);
        }
        if (!this.isCacheActive) {
            // Cache is no longer active. Pass the request through.
            return next.handle(req);
        }
        const /** @type {?} */ key = (req.method === 'GET' ? 'G.' : 'H.') + req.url;
        const /** @type {?} */ storeKey = makeStateKey(key);
        if (this.transferState.hasKey(storeKey)) {
            // Request found in cache. Respond using it.
            const /** @type {?} */ response = this.transferState.get(storeKey, /** @type {?} */ ({}));
            return observableOf(new HttpResponse({
                body: response.body,
                headers: new HttpHeaders(response.headers),
                status: response.status,
                statusText: response.statusText,
                url: response.url,
            }));
        }
        else {
            // Request not found in cache. Make the request and cache it.
            const /** @type {?} */ httpEvent = next.handle(req);
            return httpEvent
                .pipe(tap((event) => {
                if (event instanceof HttpResponse) {
                    this.transferState.set(storeKey, {
                        body: event.body,
                        headers: getHeadersMap(event.headers),
                        status: event.status,
                        statusText: event.statusText,
                        url: /** @type {?} */ ((event.url)),
                    });
                }
            }));
        }
    }
}
TransferHttpCacheInterceptor.decorators = [
    { type: Injectable }
];
/** @nocollapse */
TransferHttpCacheInterceptor.ctorParameters = () => [
    { type: ApplicationRef, },
    { type: TransferState, },
];
function TransferHttpCacheInterceptor_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    TransferHttpCacheInterceptor.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    TransferHttpCacheInterceptor.ctorParameters;
    /** @type {?} */
    TransferHttpCacheInterceptor.prototype.isCacheActive;
    /** @type {?} */
    TransferHttpCacheInterceptor.prototype.transferState;
}
/**
 * An NgModule used in conjunction with `ServerTransferHttpCacheModule` to transfer cached HTTP
 * calls from the server to the client application.
 */
export class TransferHttpCacheModule {
}
TransferHttpCacheModule.decorators = [
    { type: NgModule, args: [{
                imports: [BrowserTransferStateModule],
                providers: [
                    TransferHttpCacheInterceptor,
                    { provide: HTTP_INTERCEPTORS, useExisting: TransferHttpCacheInterceptor, multi: true },
                ],
            },] }
];
function TransferHttpCacheModule_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    TransferHttpCacheModule.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    TransferHttpCacheModule.ctorParameters;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNmZXJfaHR0cC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL21vZHVsZXMvY29tbW9uL3NyYy90cmFuc2Zlcl9odHRwLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFPQSxPQUFPLEVBQ0wsaUJBQWlCLEVBR2pCLFdBQVcsRUFHWCxZQUFZLEVBQ2IsTUFBTSxzQkFBc0IsQ0FBQztBQUM5QixPQUFPLEVBQUMsY0FBYyxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDbkUsT0FBTyxFQUFDLDBCQUEwQixFQUFFLGFBQWEsRUFBRSxZQUFZLEVBQUMsTUFBTSwyQkFBMkIsQ0FBQztBQUNsRyxPQUFPLEVBQWEsRUFBRSxJQUFJLFlBQVksRUFBQyxNQUFNLE1BQU0sQ0FBQztBQUNwRCxPQUFPLEVBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBVWpELHVCQUF1QixPQUFvQjtJQUN6Qyx1QkFBTSxVQUFVLEdBQStCLEVBQUUsQ0FBQztJQUNsRCxHQUFHLENBQUMsQ0FBQyx1QkFBTSxHQUFHLElBQUksT0FBTyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQztRQUNqQyxVQUFVLENBQUMsR0FBRyxDQUFDLHNCQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEVBQUMsQ0FBQztLQUN4QztJQUNELE1BQU0sQ0FBQyxVQUFVLENBQUM7Q0FDbkI7QUFHRCxNQUFNOzs7OztJQVNKLFlBQVksTUFBc0IsRUFBVSxhQUE0QjtRQUE1QixrQkFBYSxHQUFiLGFBQWEsQ0FBZTs2QkFQaEQsSUFBSTs7O1FBVTFCLE1BQU0sQ0FBQyxRQUFRO2FBQ1osSUFBSSxDQUNILE1BQU0sQ0FBQyxDQUFDLFFBQWlCLEVBQUUsRUFBRSxDQUFDLFFBQVEsQ0FBQyxFQUN2QyxJQUFJLENBQUMsQ0FBQyxDQUFDLENB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RTtvQkFDVCw0QkFBNEI7b0JBQzVCLEVBQUMsT0FBTyxFQUFFLGlCQUFpQixFQUFFLFdBQVcsRUFBRSw0QkFBNEIsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFDO2lCQUNyRjthQUNGIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5pbXBvcnQge1xuICBIVFRQX0lOVEVSQ0VQVE9SUyxcbiAgSHR0cEV2ZW50LFxuICBIdHRwSGFuZGxlcixcbiAgSHR0cEhlYWRlcnMsXG4gIEh0dHBJbnRlcmNlcHRvcixcbiAgSHR0cFJlcXVlc3QsXG4gIEh0dHBSZXNwb25zZVxufSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XG5pbXBvcnQge0FwcGxpY2F0aW9uUmVmLCBJbmplY3RhYmxlLCBOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Jyb3dzZXJUcmFuc2ZlclN0YXRlTW9kdWxlLCBUcmFuc2ZlclN0YXRlLCBtYWtlU3RhdGVLZXl9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xuaW1wb3J0IHtPYnNlcnZhYmxlLCBvZiBhcyBvYnNlcnZhYmxlT2Z9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHt0YXAsIHRha2UsIGZpbHRlcn0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zZmVySHR0cFJlc3BvbnNlIHtcbiAgYm9keT86IGFueSB8IG51bGw7XG4gIGhlYWRlcnM/OiB7W2s6IHN0cmluZ106IHN0cmluZ1tdfTtcbiAgc3RhdHVzPzogbnVtYmVyO1xuICBzdGF0dXNUZXh0Pzogc3RyaW5nO1xuICB1cmw/OiBzdHJpbmc7XG59XG5cbmZ1bmN0aW9uIGdldEhlYWRlcnNNYXAoaGVhZGVyczogSHR0cEhlYWRlcnMpIHtcbiAgY29uc3QgaGVhZGVyc01hcDoge1tuYW1lOiBzdHJpbmddOiBzdHJpbmdbXX0gPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgb2YgaGVhZGVycy5rZXlzKCkpIHtcbiAgICBoZWFkZXJzTWFwW2tleV0gPSBoZWFkZXJzLmdldEFsbChrZXkpITtcbiAgfVxuICByZXR1cm4gaGVhZGVyc01hcDtcbn1cblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFRyYW5zZmVySHR0cENhY2hlSW50ZXJjZXB0b3IgaW1wbGVtZW50cyBIdHRwSW50ZXJjZXB0b3Ige1xuXG4gIHByaXZhdGUgaXNDYWNoZUFjdGl2ZSA9IHRydWU7XG5cbiAgcHJpdmF0ZSBpbnZhbGlkYXRlQ2FjaGVFbnRyeSh1cmw6IHN0cmluZykge1xuICAgIHRoaXMudHJhbnNmZXJTdGF0ZS5yZW1vdmUobWFrZVN0YXRlS2V5PFRyYW5zZmVySHR0cFJlc3BvbnNlPignRy4nICsgdXJsKSk7XG4gICAgdGhpcy50cmFuc2ZlclN0YXRlLnJlbW92ZShtYWtlU3RhdGVLZXk8VHJhbnNmZXJIdHRwUmVzcG9uc2U+KCdILicgKyB1cmwpKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFwcFJlZjogQXBwbGljYXRpb25SZWYsIHByaXZhdGUgdHJhbnNmZXJTdGF0ZTogVHJhbnNmZXJTdGF0ZSkge1xuICAgIC8vIFN0b3AgdXNpbmcgdGhlIGNhY2hlIGlmIHRoZSBhcHBsaWNhdGlvbiBoYXMgc3RhYmlsaXplZCwgaW5kaWNhdGluZyBpbml0aWFsIHJlbmRlcmluZyBpc1xuICAgIC8vIGNvbXBsZXRlLlxuICAgIGFwcFJlZi5pc1N0YWJsZVxuICAgICAgLnBpcGUoXG4gICAgICAgIGZpbHRlcigoaXNTdGFibGU6IGJvb2xlYW4pID0+IGlzU3RhYmxlKSxcbiAgICAgICAgdGFrZSgxKVxuICAgICAgKS50b1Byb21pc2UoKVxuICAgICAgLnRoZW4oKCkgPT4geyB0aGlzLmlzQ2FjaGVBY3RpdmUgPSBmYWxzZTsgfSk7XG4gIH1cblxuICBpbnRlcmNlcHQocmVxOiBIdHRwUmVxdWVzdDxhbnk+LCBuZXh0OiBIdHRwSGFuZGxlcik6IE9ic2VydmFibGU8SHR0cEV2ZW50PGFueT4+IHtcbiAgICAvLyBTdG9wIHVzaW5nIHRoZSBjYWNoZSBpZiB0aGVyZSBpcyBhIG11dGF0aW5nIGNhbGwuXG4gICAgaWYgKHJlcS5tZXRob2QgIT09ICdHRVQnICYmIHJlcS5tZXRob2QgIT09ICdIRUFEJykge1xuICAgICAgdGhpcy5pc0NhY2hlQWN0aXZlID0gZmFsc2U7XG4gICAgICB0aGlzLmludmFsaWRhdGVDYWNoZUVudHJ5KHJlcS51cmwpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5pc0NhY2hlQWN0aXZlKSB7XG4gICAgICAvLyBDYWNoZSBpcyBubyBsb25nZXIgYWN0aXZlLiBQYXNzIHRoZSByZXF1ZXN0IHRocm91Z2guXG4gICAgICByZXR1cm4gbmV4dC5oYW5kbGUocmVxKTtcbiAgICB9XG5cbiAgICBjb25zdCBrZXkgPSAocmVxLm1ldGhvZCA9PT0gJ0dFVCcgPyAnRy4nIDogJ0guJykgKyByZXEudXJsO1xuICAgIGNvbnN0IHN0b3JlS2V5ID0gbWFrZVN0YXRlS2V5PFRyYW5zZmVySHR0cFJlc3BvbnNlPihrZXkpO1xuXG4gICAgaWYgKHRoaXMudHJhbnNmZXJTdGF0ZS5oYXNLZXkoc3RvcmVLZXkpKSB7XG4gICAgICAvLyBSZXF1ZXN0IGZvdW5kIGluIGNhY2hlLiBSZXNwb25kIHVzaW5nIGl0LlxuICAgICAgY29uc3QgcmVzcG9uc2UgPSB0aGlzLnRyYW5zZmVyU3RhdGUuZ2V0KHN0b3JlS2V5LCB7fSBhcyBUcmFuc2Zlckh0dHBSZXNwb25zZSk7XG4gICAgICByZXR1cm4gb2JzZXJ2YWJsZU9mKG5ldyBIdHRwUmVzcG9uc2U8YW55Pih7XG4gICAgICAgIGJvZHk6IHJlc3BvbnNlLmJvZHksXG4gICAgICAgIGhlYWRlcnM6IG5ldyBIdHRwSGVhZGVycyhyZXNwb25zZS5oZWFkZXJzKSxcbiAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgIHVybDogcmVzcG9uc2UudXJsLFxuICAgICAgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZXF1ZXN0IG5vdCBmb3VuZCBpbiBjYWNoZS4gTWFrZSB0aGUgcmVxdWVzdCBhbmQgY2FjaGUgaXQuXG4gICAgICBjb25zdCBodHRwRXZlbnQgPSBuZXh0LmhhbmRsZShyZXEpO1xuICAgICAgcmV0dXJuIGh0dHBFdmVudFxuICAgICAgICAucGlwZShcbiAgICAgICAgICB0YXAoKGV2ZW50OiBIdHRwRXZlbnQ8YW55PikgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgSHR0cFJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgIHRoaXMudHJhbnNmZXJTdGF0ZS5zZXQoc3RvcmVLZXksIHtcbiAgICAgICAgICAgICAgICBib2R5OiBldmVudC5ib2R5LFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGdldEhlYWRlcnNNYXAoZXZlbnQuaGVhZGVycyksXG4gICAgICAgICAgICAgICAgc3RhdHVzOiBldmVudC5zdGF0dXMsXG4gICAgICAgICAgICAgICAgc3RhdHVzVGV4dDogZXZlbnQuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgICB1cmw6IGV2ZW50LnVybCEsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQW4gTmdNb2R1bGUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGBTZXJ2ZXJUcmFuc2Zlckh0dHBDYWNoZU1vZHVsZWAgdG8gdHJhbnNmZXIgY2FjaGVkIEhUVFBcbiAqIGNhbGxzIGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50IGFwcGxpY2F0aW9uLlxuICovXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQnJvd3NlclRyYW5zZmVyU3RhdGVNb2R1bGVdLFxuICBwcm92aWRlcnM6IFtcbiAgICBUcmFuc2Zlckh0dHBDYWNoZUludGVyY2VwdG9yLFxuICAgIHtwcm92aWRlOiBIVFRQX0lOVEVSQ0VQVE9SUywgdXNlRXhpc3Rpbmc6IFRyYW5zZmVySHR0cENhY2hlSW50ZXJjZXB0b3IsIG11bHRpOiB0cnVlfSxcbiAgXSxcbn0pXG5leHBvcnQgY2xhc3MgVHJhbnNmZXJIdHRwQ2FjaGVNb2R1bGUge31cbiJdfQ==